#!/usr/bin/env ruby

require 'jgrep'
require 'optparse'

options = {:flat => false}

OptionParser.new do |opts|
    opts.banner = "Usage: jgrep [options] \"expression\""
    opts.on("-s", "--simple FIELD[s]", "Display a single field from each of the resulting json documents") do |field|
        if (field.split(" ")).size > 1
            options[:field] = field.split(" ")
        else
            options[:field] = field
        end
    end

    opts.on("-f", "--flat", "Display non pretty json") do
        options[:flat] = true
    end

    opts.on("-v", "--verbose", "Verbose output") do
        JGrep::verbose_on
    end

end.parse!

begin
    expression = nil

    #Identify the expression from command line arguments
    ARGV.each do |argument|
        if argument =~ /<|>|=/
            expression = argument
            ARGV.delete(argument)
        end
    end

    #Load json from standard input if tty is false
    #else find and load file from command line arugments
    unless STDIN.tty?
        json = STDIN.read
    else
        if ARGV.size == 1
            json = File.read(ARGV.first)
        else
            raise "No json input specified"
        end
    end

    unless options[:field]
        result = JGrep::jgrep((json), expression)
        unless result == []
            (options[:flat] == false) ? puts(JSON.pretty_generate(result)) : puts(result.to_json)
        end

    else
        if options[:field].is_a? Array
            JGrep::validate_filters(options[:field])
            puts(JSON.pretty_generate(JGrep::jgrep((json), expression, options[:field])))

        else
            JGrep::validate_filters(options[:field])
            result = JGrep::jgrep((json), expression, options[:field])
            unless result.first.is_a?(Hash) || result.flatten.first.is_a?(Hash)
                result.map{|x| puts x unless x.nil?}
            else
                puts(JSON.pretty_generate(result))
            end
        end
    end
rescue Exception => e
    STDERR.puts "Error - #{e}"
    exit 1
end
